---
title: java编程思想笔记(下)
date: 2017-06-8 22:46:20
tags:
  - java
categories: java相关
---

### 11. 通过异常处理错误
* Java的基本理念是“**结构不佳的代码不能运行**”。

* 使用异常往往能够降低错误处理代码的复杂度，把“**描述在正常执行过程中做什么事**”的代码和“**出了问题怎么办**”的代码分离。

* 异常最重要的方面之一就是如果发生问题，它们将不允许程序沿着其正常的路径继续走下去。

* 所有标准异常类都有两个构造器：**一个是默认构造器**，**另一个是接受字符串作为参数**，以便能把相关信息放入异常对象的构造器。

* 要自定义异常，必须从已有的异常类继承。建立新的异常类型最简单的方法就是让编译器为你产生默认构造器；也可以为异常类定义一个接受字符串参数的构造器。**对异常来说，最重要的部分就是类名**。

* Java鼓励人们把方法可能会抛出的异常告知使用此方法的客户端程序员，这就是异常说明。

* 异常说明属于方法的一部分，紧跟在形式参数列表之后。异常说明使用了关键字`throws`，后面接一个所有潜在异常类型的列表：`void f() throws TooBig, TooSmall{}`.

* 如果方法里面的代码产生了异常却没有进行处理，编译器会提醒你：**要么处理这个异常，要么就在异常说明中表明此方法将产生异常**。

* 可以只写一个异常处理程序来捕获所有类型的异常。通过捕获异常类型的基类`Exception`，`catch(Exception e){...}`这将捕获所有异常，所以最好把它放在处理程序列表的末尾。

* Throwable这个java类被用来表示任何可以作为异常被抛出的类。

* Throwable对象可以分为两类：
    1. Error用来表示编译时和系统错误。
    2. Exception是可以被抛出的基本类型。


* 异常的基本概念是用名称代表发生的问题。

* 运行时异常被Java虚拟机抛出，所以不必在异常说明中把它们列出来，这些异常都是从RuntimeException类继承而来。

* 务必记住：只能在代码中忽略RuntimeException（及其子类）类型的异常，其他类型异常的处理都是由编译器强制实施的。究其原因，RuntimeException代表的是编程错误。

### 12. 字符串
* String对象是不可变的，String中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象。

*　用于String的“＋”与“＋＝”是**Java中仅有的两个重载过的操作符**。

* `StringBuilder`是Java SE5引入的，在这之前用的是`StringBuffer`，后者是线程安全的。

* 在Java中，所有新的格式化功能都由java.util.Formatter类处理。

* `String.format()`是一个`static`方法，它接受与`Formatter.format()`方法一样的参数，但返回一具String对象。

### 13. 类型信息
* 运行时类型信息使得你可以在程序运行时发现和使用类型信息。

* java如何在运行时识别对象和类的信息，主要有两种方式：一种是**RTTI**，它假定我们在**编译时**已经知道了所有的类型；另一种是**反射**，它允许我们在**运行时**发现和使用类的信息。

* 典型的类层次结构图，**基类位于顶部，派生类向下扩展**。面向对象编程中基本的目的是：让代码只操纵对基类的引用。

* Class对象就是用来创建类的所有的“常规”对象。

* 类是程序的一部分，每个类都有一个Class对象。一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象。

* 无论何时，只要你想在运行时使用类型信息，就必须首先获得对恰当的Class对象的引用。`Class.forName()`就是实现此功能的便捷途径。

* Class的`newInstance()`方法是实现“虚拟构造器”的一种途径，虚拟构造器允许你声明：“**我不知道你的确切类型，但是无论如何要正确地创建你自己**”。使用`newInstance()`来创建的类，**必须带有默认的构造器**。

* Java还提供了另一种方法来生成对Class对象的引用，即使用类字面常量：Foo.class;并且它根除了对forName()方法的调用，所以也更高效。

* 使用.class语法来获得对类的引用不会引发初始化，但是为了产生Class引用，Class.forName()立即就进行了初始化。

* 泛化的Class引用，允许你对Class引用所指向的Class对象的类型进行限定。

* `Class`类与`java.lang.reflect`类库一起对反射的概念进行了支持。

* 反射和RTTI之间真正的区别只在于，对RTTI来说，编译器在编译时打开和检查.class文件；而对于反射机制来说，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件。

### 14. 泛型

* 泛型这个术语的意思是：适用于许多许多的类型。

* 许多原因促成了泛型的出现，而最引人注目的一个原因就是为了创造容器类。

* 类型参数：**用尖括号括住，放在类名后面**。

* 泛型的核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一切。

* Java泛型的一个局限性：基本类型无法作为类型参数。不过Java SE5具备了自动打包和自动拆包的功能，可以很方便地在基本类型和其相应的包装器类型之间进行转换。

* 泛型可以用于类也可以用于方法。也就是说，是否拥有泛型方法与其所在的类是否是泛型没有关系。

* 如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法。

* 要定义泛型方法只需要将泛型参数列表置于返回值之前：`public <T> void f(T x){}`。

* 当使用泛型类时，必须在创建对象时指定类型参数的值：`Foo<Integer> foo = new Foo<Integer>();`而使用泛型方法时通常不必指明参数类型，因为编译器会类型参数推断。

* 泛型方法与可变参数列表能够很好地共存：`public static <T> List<T> makeList(T... args){};`

* 在泛型代码内部，无法获得任何有关泛型参数类型的信息。

* Java泛型是使用擦出来实现的，这意味着当你使用泛型时，**任何具体的类型信息都被擦除了**，你唯一知道的就是你在使用一个对象。

* 边界<T extends HasF> 声明T必须具有类型HasF或者从HasF导出的类型。

* 只有当你希望使用的类型参数比某个具体类型更加泛化时——也就是说，当你希望代码能够跨多个类工作时，使用泛型才有所帮助。

* 擦除的核心动机是它使得泛化的客户端可以用非泛化的类库。

* 泛型不能用于显式地引用运行时类型的操作之中，例如转型、instanceof操作和new表达式。任何需要知道确切类型信息的操作都将无法工作：
    ```
    public class Erased<T>{
        private final int SIZE = 100;
        public static void f(Object arg){
            if(arg instanceof T){} // Error
            T var = new T();       // Error
            T[] array = new T[SIZE]// Error
            T[] array = (T)new Object[SIZE] // Unchecked warning
        }
    }
    ```


* **任何基本类型都不能作为类型参数**，因此不能创建`ArrayList<int>`之类的东西。

* 一个类不能实现同一个泛型接口的两种变体，由于控除的原因，这两个变体会成为相同的接口：
    ```
    interface Payable<T>{}
    class Employee implements Payable<Employee>{}
    class Hourly extends Employee implements Payable<Hourly>{}
    // 意味着在重复两次地实现相同的接口。
    ```


* 由于控除的原因，重载方法将产生相同的类型签名：
    ```
    public class UseList<W,T>{
    void f(List<T> v){}
    void f(List<W> v){}
    // 不能编译
    }
    ```

### 15. 数组

* 数组是一种效率最高的存储和随机访问对象引用序列的方式。与其它容器之间的区别有三方面：效率、类型和保存基本类型的能力。

* 随着自动包装机制的出现，容器已经可以与数组几乎一样方便地用于基本类型中了，数组硕果仅存的优点就是效率。

* 对象数组和基本类型数组在使用上几乎是相同的；唯一的区别就是对象数组保存的是引用，基本类型数组直接保存基本类型的值。

* 新生成一个数组**对象时，其中所有的引用被自动初始化为null**；基本类型的数组如果是**数值的，就自动被初始化为0**，如果是**字符型（char）的，就自动被初始化为(char)0**，如果是**布尔型（boolean）就自动初始化为false**。

* 返回一个数组与返回任何其它对象（实质上是返回引用）没什么区别。

* 在java.util类库中可以找到Arrays类，它有一套用于数组的static实用方法。

### 16. 容器深入研究
* 尽管只有四种容器：Map、List、Set和Queue，但是每种接口都不止一个实现版本。

### 17. Java I/O系统
* File 类这个名字有一定的误导性，它既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称。

* Java中“流”类库让人迷惑的主要原因就在于：创建单一的结果流，却要创建多个对象。

* `InputStream`和`OutputStream`在以面向**字节**形式的I/O中仍可以提供极有价值的功能；`Reader`和`Writer`则提供兼容Unicode与面向**字符**的I/O功能。

* InputStremReader可以把InputStream转换为Reader,而OutputStreamWriter可以把OutputStream转换为Writer。

* 设计Reader和Writer继承层次结构的主要是为了国际化。

* Java I/O类库中的类支持读写压缩格式的数据流————直接将输出流封装成GZIPOutputStream或ZipOutputStream，并将输入流封装成GZIPInputStream或ZipInputStream。

* Zip格式也被应用于JAR文件格式中，一个JAR文件由一组压缩文件构成，同时还有一张描述了所有这些文件的“文件清单”。

* Java的对象序列化将那些实现了Serializable接口的对象转换成一个字节序列 ，并能够在以后将这个字节序列完全恢复为原来的对象。

### 18. 枚举类型

* 关键字`enum`可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用。

* 调用`enum`的`values()`方法，可以遍历enum实例。values()方法返回enum实例的数组，而且该数组中的元素严格保持其在enum中声明时的顺序。

* 除了不能继承自一个enum之外，我们基本上可以将enum看作一个常规的类。也不是说，我们可以向enum中添加方法，enum甚至可以有main()方法。

* 在`switch`中使用`enum`，是enum提供的一项非常便利的功能。在switch中只能使用整数值，而枚举实例天生就具备整数值的次序。

### 19. 注解

* 注解（元数据）为我们代码中添加信息提供了一种形式化的方法，使得我们可以在稍后某个时刻非常方便地使用这些数据。

* Java SE5内置了三种，定义在java.lang中的注解：
    1. `@Override` 表示当前方法将覆盖超类中的方法。
    2. `@Deprecated` 编译器发出警告信息。
    3. `@SuppressWarnings` 关闭不当的编译器警告信息。

* 以及四种元注解：
    1. `@Target` 表示该注解可以用于什么地方。(CONSTRUCTOR,FIELD,LOCAL_VARIABLE,METHOD,PACKAGE,PARAMETER,TYPE)
    2. `@Retention` 表示在什么级别保存该注解信息。(SOURCE,CLASS,RUNTIME)
    3. `@Documented` 将此注解包含在Javadoc中。
    4. `@Inherited` 允许子类继承父类中的注解



* 定义接口很像接口的定义，定义注解时需要一些元注解，如@Target和@Retention。

* 注解的元素看起来就像接口的方法，唯一的区别是你可以为其指定默认值。

* 没有元素的注解称为标记注解。

* 如果没有用来读取注解的工具，那注解也不会比注释更有用。使用注解过程中，很重要的一个部分就是**创建与使用注解处理器**。

* 注解元素可以使用的类型如下：
    * 所有的基本类型（int，float，boolean等）
    * String
    * Class
    * enum
    * Annotation


### 20. 并发
* 在使用线程时，cpu将轮流给每个任务分配其占用的时间，每个任务都觉得自己一直在占用CPU，但事实上CPU是划分成片段分配了所有的任务。
