---
title: java编程思想笔记
date: 2017-04-19 22:19:20
tags:
  - java
categories: java相关
---

### 1. 一切都是对象
* 创建了一个引用，就希它能与一个对象相关联。new操作符的意思是：“给我一个对象”。

* 基本类型存储到**堆栈**。
* 对象类型存储到**堆**。

* java基本类型所占存储空间大小是**不变**的:

基本类型 | 大小 | 包装器类型
--|---|--
void | - | Void
boolean | - | Boolean
byte | 8 bits | Character
char | 16 bits| Character
short | 16 bits | Short
int | 32 bits | Integer
long | 64 bits | Long
float | 32bits| Float
double | 64 bits | Double


* 若类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保它获得一个默认值。

* 调用对象的方法在面向对象中等同于向对象发送消息。

* Java消除了所谓的“向前引用”的问题，可以直接使用在程序里预先定义的类——即使这个类在文件 的后面才会被定义。

* 当声明一个事物是static时，就意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。

* 使用类名是引用static变量的首选方式，这不仅是因为它强调了变量的static结构，而且在某些情况下它还会为编译器进行优化提供更好的机会。

* static方法的一个重要用法就是在创建任何对象的前提下就可以调用它。

* 有一个特定类会被自动导入到每一个java文件中：**java.lang**。

* 所有javadoc命令都只能在"/**"中出现，共有三种类型的注释文档：类、域、方法。

* javadoc只能为public和protected成员进行文档注释；private和包内可访问成员的注释会被忽略。

* javadoc的一些常用标签：
    * @see 引用其它类
    * @docRoot 该标签产生到根目录的相对路径
    * @version 版本信息
    * @author 作者信息
    * @since 指定程序最早使用版本
    * @param 参数描述
    * @return 描述返回值
    * @throws 异常

### 2. 操作符
* 对一个对象进行赋值时，我们真正操作的是对象的引用。

* 整数的除法会直接去掉结果的小数位，而不是四舍五入。

* 对于前缀递增和前缀递减（++a或--a）会先执行运算，再生成值。

* 对于后缀递增和后缀递减（a++或a++）会先生成值，再执行运算。

* == 和 != 比较的就是对象的引用。对象的内容相同，然后对象的引用却是不同的。

* 基本类型直接使用 == 和 != 进行比较，但相比较两个对偶的实际内容是否相同时，必须使用方法：**equals()**。

* equals()的默认行为是比较引用，如果想让自己的类表现一致，必须重写equals()方法。

* 直接常量后面的后缀字符标志了它类型：
    * 大写或小写的L代表Long。
    * 大写或小写的F代表Float。
    * 大小或小写的D代表Double。


* **java不会自动地将int数值转换成布尔值。**

* java允许我们把任何基本数据类型转换成别的基本数据类型，但布尔值除外。布尔值不允许任何类型转换处理。

* 提升：表达式中出现的最大数据类型决定了表达式最终结果的数据类型。如果将float与double相乘，结果就是double。

* java不需要sizeof()操作符来满足这方面的需要，因为所有数据类型在所有机器中的大小都是相同的。

* 对够对布尔类型进行的运算非常有限。我们只能赋予它true或false值，并测试它，而不能进行其它任何运算。

### 3. 控制执行流程
* java并不支持goto语句，但仍可以进行类似goto那样的跳转：**标签+break\continue**。

* java里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break或continue。

* java不允许我们将一个数字作为布尔值使用，虽然这在C和C++里是允许的。

* while和do-whiler唯一区别就是do-while中的语句至少会执行一次。

* java里唯一用到逗号操作符的地方就是for循环的控制表达式。

* switch的选择因子必须是int或char那样的整数值。

### 4. 初始化与清理
* 构造器与类名相同，不接受任何参数的构造器叫做默认构造器。

* 构造器是一种特殊类型方法，因为它没有返回值。

* 重载的方法必须有一个独一无二的参数类型列表。

* 根据方法返回值来区别重载方法是行不通的。

* 默认构造器（又名无参构造器）是没有形式参数的——它的作用是创建一个“默认对象”：
    * 如果你写的类中没有构造器，编译器会自动帮你创建一个默认构造器。
    * 如果已经定义了构造器（无论是否有参），编译器就不会帮你创建默认构造器。


* this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。

* 除了构造器外，编译器禁止在其他任何方法中调用构造器。

* static方法就是没有this的方法。可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法，这正是static方法的主要用途。

* finalize()方法的工作原理“假定”是这样的：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法。

* 正由于垃圾回收机制的存在，使得java没有析构函数。

* 类的每个基本类型数据成员保证都会有一个初始值。在类里定义一个对象引用时，如果不将其初始化，此引用就会获得一个特殊值null。

* 在类的内部，变量定义的先后顺序决定了初始化的顺序。初始化的顺序是先静态对象，而后是“非静态”对象。

* 类的成员初始化方式：
    * 定义成员变量的时候赋值（**优点：简单、直观，缺点：但是每个对象都会具有相同的初始值**）。
    * 静态块初始化，**优先级最高最先执行，并且仅在类第一次被加载时执行**。
    * 非静态块初始化，**始化块的代码会在类构造函数之前执行**，应当养成把初始化块写在构造函数之前的习惯。
    * 构造器初始化（**优点：更大灵活性，缺点：无法阻止自动初始化的进行**）。


* 数级元素中的基本数据类型值会自动初始化成空值。

* 非基本类型的数组初始化：
    * `Integer[] a = new Integer[rand.nextInt(20)]`;//只能用于定义
    * `Integer[] a = {new Integer(1), new Integer(2)}`;
    * `Integer[] a = new Integer[]{new Integer(1), new Integer(2)}`;


### 5. 访问权限控制
* 访问控制权限排序：`public > protected > package > private`.

* 当编写java源代码文件时，此文件称为编译单元，每个编译单元必须有一个后缀名.java。而在编译单元内可以有一个public类，该类的名称必须与文件的名称相同（包括大小写）。每个编译单元只能有一个public类。

* 在.java文件中的**每个类**，都会有一个**输出文件**。

* 如果使用package语句，它必须是文件中除注释以外的第一句程序代码。包的命令规则全部使用小写字母。

* 创建包时，必须遵守“**包的名称对应目录路径**”。

* public、protected、private这几个访问权限修饰词在使用时，是置于类中每个成员的定义之前的——**无论它是一个字段还是一个方法**。

* 如果不提供任何访问权限修饰词，则意味着它是“包访问权限”。

* 包访问权限**意味着当前包中的所有其它类对那个成员都有访问权限，但对于这个包之外的所有类，这个成员却是 private**。

* 当把类组织起来放进一个包内时，也就给它们的包访问权限的成员赋予了相互访问的权限。

* 访问权限也可以用于确定库中的哪些类对于该库的使用者是可用的。

* 为控制某个类的访问权限，修饰词必须出现于关键字class之前：`public class Widget`。
    * 每个编译单元都只能有一个public类。
    * public类的名称必须完全与含有该编译单元的文件名相匹配，包括大小写。
    * 编译单元内完全不带public类也是可能的。在这种情况下，可以随意对文件命名。

* 类名不带访问权限修饰的就是包访问权限（**该类只可以用于该包中**）。

* 请注意：**类既不可以是private也不可以是protected的**（内部类可以是private或是protected，但那是一个特例）。

* 类的访问权限，仅有两个选择：包访问权限或public。

### 6. 复用类

*  代码复用的两种方法：**组合**与**继承**，第三种是代理。

* 代理是继承与组合之间的中庸之道：将一个成员对象置于所要构造的类中（像组合），但与此同时我们在新类中暴露该成员对象的所有方法。

* 在子类中对基类对象的正确初始化是至关重要的，而且也仅有一种方法来保证这一点：**在构造器中调用基类构造器来执行初始化**。

* 当基类含有默认的构造器（即这些构造器都不带参数），**编译器可以自动调用基类的构造器来初始化**。

* 但是**如果没有默认的基类构造器的语句，或者想调用一个带参数的基类构造器**，就必须用关键字super显式地编写调用基类构造器的语句。

* 调用基类构造器必须是你在子类构造器中要做的第一件事。

* 如果Java的基类拥有某个已被多次重载的方法名称，那么在子类中重新定义该方法名称并不会屏蔽其在基类中的任何版本。

* 在组合与继承之间的选择：
    * 组合("has-a"有一个关系)：通常用于相在新类中使用现有类的功能而非它的接口这种情形。
    * 继承("is-a"是一个关系)：意味着你在使用一个通用类，并为了某种特殊需要而将其特殊化。

* protect关键字：**就类用户而言，这是private的，但对于任何继承于此类的子类或其它任何位于同一个包内的类来说，它却是可以访问的**。

* 向上转型：由子类转换成基类，在继承图上是向上移动的，因此一般称为向上转型。

* 到底该使用组合还是继承，一个清晰的判断方法就是**问一问自己是否需要从新类向基类进行向上转型，如果必须向上转型，则继承是必要的**。

* final关键字根据上下文环境存在区别，但通常指的是“**这是无法改变的**”。

* 可能使用到final的三种情况：数据、方法、类。

* final数据，来向编译器告知一块数据是恒定不变的：
    * 一个既是static又是final的域只占据一段不能改变的存储空间。
    * 对基本类型，final使数值恒定不变。
    * 对引用类型，final使引用恒定不变，一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象。**然而对象自身是可以被修改的**。
    * java并未提供使任何对象恒定不变的途径。
    * java允许“空白final”指被声明但又未给定初值的字段。必须在字段或者每个构造器中用表达式对final进行赋值，这正是final字段在使用前总是被初始化的原因所在。
    * java允许在参数列表中以声明的方式将参数指明为final。这意味着你无法在方法中更改参数引用所指的对象。


* final方法，使用原因有两个 **设计** 和效率：
    * 把方法锁定，以防止任何继承类修改它的含义。这是出于设计的考虑。
    * 过去建议使用final是出于效率，但现在已不需要，**只有想在明确禁止覆盖时，才将方法设为final**。
    * 类中所有 private 方法都隐式地指定为是 final 的。**可以对 private 方法添加 final 修饰，但是这毫无意义**。


* final类：不允许继承该类、不希望有子类、该类的设计永不需要做任何变动：
    * 由于final类中禁止继承，所以final类中所有的方法都隐式指定为final的，**因为它们无法覆盖**。
    * 在final类可以给方法添加 final 修饰，但是这毫无意义。


* java 的初始化顺序：**基类static -> 子类static -> 基类构造函数 -> 子类构造函数**。

* 继承和组合都能从现有类型生成新类型。**组合一般是将现有类型作为新类型底层实现的一部分来加以复用，而继承复用的是接口**。

* 尽管面向对象极力强调继承，但是一般应优先选择使用组合（或代理），只有确实必要时才使用继承。因为组合更具灵活性。

### 7. 多态

* **多态**是继**数据抽象**和**继承**之后的第三种基本形态。

* 对象既可以作为它自己本身的类型使用，也可以作为它的基类型使用。而这种把对某个对象引用视为对其基类型的引用的做法称为**向上转型**。

* 多态所允许的就是，写一个方法让它接收基类作为参数，而不是扩展类。

* 将一个方法调用同一个方法主体关联起来被称作绑定：
    * 前期绑定：在程序执行前进行绑定。
    * 后期绑定：在程序运行时根据对象的类型进行绑定。（动态绑定或运行时绑定）


* 动态绑定，编译器一直不知道对象的类型，但是方法调用机制能找到正确的方法体。

* Java中除了static方法和final方法（private方法属于final方法）之外，**其他所有的方法都是动态绑定**。

* 一旦知道**Java中所有方法都是通过动态绑定多态**这个事实后，我们就**可以编写只与基类打交道的程序代码**了。

* 多态方法的调用，**在编译时，编译器不需要获得任何特殊信息就能进行正确的调用**。

* 由于private方法被自动认为是final的，而且对扩展类是屏蔽的。**所以只有非private方法才可以被覆盖**。

* 构造器实际上是由static隐式声明的。

* 构造器不同于其他种类方法，涉及到多态时仍是如此。**构造器不具有多态性**。

* 基类构造器总是在导出类的构造过程中被调用，按照继承层次逐渐向上链接。

* 在子类的构造器中，如果没有明确指定调用某个基类构造器，它就会“默默”地调用默认构造器。如果不存在默认构造器，编译器就会报错。

* 对象构造器的调用顺序：
    0. 在其它任何事物发生之前，将分配给对象的存储空间初始化成二进制的0。
    1. 调用基类构造器，递归到最上层。也就是最先调用最上层的基类构造器。
    2. 按声明顺序调用成员的初始化方法。
    3. 调用对象的构造函数。


* 编写构造器的准则：**用尽可能简单的方法使对象进入正常状态；如果可以的话，避免调用其他方法**。构造器内唯一能够安全调用的那些方法是基类中的final方法。

* 用继承进行设计时，更好的方式是选择组合，“用继承表达行为间的差异，用组合表达状态上的变化”。

### 8. 接口

* **接口**和**内部类**为我们提供了一种将接口与实现分离的更加结构化的方法。

* **抽象类**，是**普通类**与**接口**之间的一种中庸之道。

* 抽象方法：仅有**声明**而没有方法体。`abstract void f();`

* 抽象类：**包含抽象方法的类**，如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的。

* 如果从一个抽象类继承，并想创建该新类对象，**那么就必须为基类中的所有抽象方法提供方法定义**，否则该导出类也是抽象类。

* **interface**关键字使抽象的概念更向前了一步，它产生了一个完全抽象的类。（**abstract**关键字允许人们创建**一个或多个**没任何定义的方法）

* 一个接口表示：“**所有实现了该特定接口的类看起来都像这样**”。

* 接口允许人们通过创建一个能够被向上转型为多种基类的类型，来实现某种类似多重继承变种的特性。

* 接口可以包含域，但是这些域**隐式地是static和final**的。

* 接口中的方法可以声明为public的，**但是即使不这么做，它们也是public的**。（在接口中的定义的方法必须被定义为是public的）。

* java的多重继承：需要将所有的接口名都置于**implements**关键字后面，用逗号将它们一一隔开。可以继承任意多个接口，并且可以向上转型为每个接口，因为每个接口都是一个独立类型。

*将一个具体类和多个接口组合到一起时，这个具体类必须放在前面，后面跟着的才是接口。`class Hero extends Base implements CanFight, CanSwim, CanFly{}`

* 使用接口的核心原因：**为了能够向上转型为多个基类型**。

* 使用接口的第二个原因：与使用抽象基类相同，防止客户端程序员创建该类的对象，并确保这仅仅是建立一个接口。

* 选择使用接口还是抽象类？如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。

* 接口可以继承接口：`interface foo{...};interface bar extends foo{...}`

* 接口中的域：任何放入接口中的域都自动是static和final的，所以接口就成为了一种很便捷的用来创建常量的工具。


### 9. 内部类

* 可以将一个类的定义放在另一个类的定义的内部，这就是内部类。

* 创建内部类的方式就如你想的一样——把类的定义置于外围类的里面。

* 如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须指明这个对象的类型：`OuterClassName.InnerClassName`即：**外部类名.内部类名**。

* 内部类能访问其外围对象的所有成员，而不需要任何特殊条件。

* **内部类还拥有其外围类的所有元素的访问权**包括private字段。

* 如果在内部类里面需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this：
```
public clas DotThis{
    void f(){
        System.out.println("DotThis.f();)
    }
    public class Inner{
        public DotThis outer(){
            return DotThis.this; // here
        }
    }
    public Inner inner(){
        return new Inner();
    }
    public static void main(String[] args){
        DotThis dt = new DotThis();
        DotThis.Inner dti = dt.inner(); // define Inner Class
        dti.outer.f();
    }
    //output: DotThis.f()
}
```

* 有时你可能想要告知某些其他对象，**去创建其某个内部类的对象**。要实现些目的，你必须在new表达式中提供对其他外部类对象的引用，这就需要**.new语法**：
```
public class DotNew{
    public class Inner{}
    public static void main(String[] args){
        DotNew dn = new DotNew();
        DotNew.Inner dni = dn.new Inner(); // here
    }
}
```

* 可以在一个方法里面或者在任意的作用域内定义内部类。

* 如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。这通常称为**嵌套类**。

* 普通内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而当内部类是static时，就不是这样了：
    1. 要创建嵌套类的对象，并不需要其外围类的对象。
    2. 不能从嵌套类的对象中访问非静态的外围类对象。


* **为什么需要内部类？**一般来说内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类对象。所以可以认为**内部类提供了某种进入其外围类的窗口**。

* 内部类必须要回答的一个问题是：如果只是需要一个对接口的引用，为什么不通过外围类实现那个接口呢？答案是“**如果这么满足需求，那么就应该这样做**”。

* 每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。

* 内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效的实现了“多重继承”，也就是说，**内部类允许继承多个非接口类型**。

* 内部类是面向对象的**闭包**，因为它不仅包含外围类对象的信息，还自动拥有一个指向些外围类对象的引用，在此作用域内，内部类有权操作所有成员，包括private成员。


* 每个类都会产生一个.class文件，内部类也必须生成一个.class文件以包含它们的Class对象信息。这些类文件的命名有严格的规则：**外围类的名字，加上"$"，再加上内部类的名字**。


### 10. 持有对象
* Java提供了一套相当完整的容器类，其中基本的类型是List、Set、Queue和Map。这些对象也称为集合类。

* 如果一个类没有显式的声明继承自哪个类，那么它自动的继承自Object。

* Java容器类类库的用途是“保存对象”，并将其划分为两个不同的概念：
    1. Collection。一个独立元素的序列，这些元素都服从一条或多条规则。List必须按照插入的顺序保存元素，而Set不能有重复元素。Queue按照排队规则来确定产生的顺序。
    2. Map。一级成对的“键值对”对象，允许你使用键来查找值。


* 在理相情况下，你编写的大部分代码都是在与这些**接口**打交道。并且你唯一需要指定所使用的精确类型的地方就是在创建的时候：`List<Apple> apples = new ArrayList<Apple>();`

* 使用接口的目地在于如果你决定去修改你的实现，你所需的只是在创建出修改它。就像下面这样：`List<Apple> apples = new LinkedList<Apple>();`

* Collection接口概括了序列的概念——一种存放一组对象的方式。
    1. List，它以特定的顺序保存一组元素。
    2. Set，元素不能重复。
    3. Queue，只允许在容器的一“端”插入对象，并从另外一“端”移除对象。


* 基本的ArrayList，它长于随机访问元素，但是在List的中间插入和移除元素时较慢。
* LinkedList，它通代价较低的在List中进行插入和删除，提供了优化的顺序访问。LinkedList在随机访问方面相对比较慢。


* 迭代器统一了对容器的访问方式：
    1. 使用方法iterator()要求容器返回一个Iterator。
    2. 使用next()获得序列中的下一个元素。
    3. 使用hesNext()检查序列中是否还有元素。
    4. 使用remove()将迭代器新近返回的元素删除。


* 数组将数字与对象联系起来，但是数组一旦生成，其容量就不能改变。

* 容器不能持有基本类型，但是自动包装机制会仔细地执行基本类型到容器中所持有的包装器类型之间的双向转换。

* 如果要进行大量的随机访问，就使用ArrayList；如果要经常从表中间插入或删除元素，则应该使用LinkedList。

* 各种Queue以及栈的行为，由LinkedList提供支持。

* Map是一种将对象与对象关联的设计。HashMap设计用来快速访问；而TreeMap保持“键”始终处于排序状态，所以没有HashMap快，LinkedHashMap保持元素插入的顺序，但是也通过散列提供了快速访问能力。

* Set不接受重复元素，HashSet提供最快的查询速度，而TreeSet保持元素处于排序状态。LinkedHashSet以插入顺序保存元素。

只有四种容器：Map、List、Set和Queue，它们各有两到三个实现版本。
