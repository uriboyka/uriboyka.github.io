---
title: Effective Java第二版
date: 2017-08-16 22:39:59
tags:
  - java
categories: java
---

### 1. 考虑用静态工厂方法代替构造器
* 静态工厂方法与构造器不同的优势在于：
    1. 它们有名称。
    2. 不必在每次调用它们的时候都创建一个新对象。
    3. 它们可以返回原来返回类型的任何子类型的对象。
    4. 在创建参数化类型实例的时候，它们使代码变得更加简洁。


* 静态工厂方法的缺点在于：
    1. 类如果不含有公有的或者受保护的构造器，就不能被子类化。
    2. 它们与其他的静态方法实际上没有任何区别。


### 2. 遇到多个构造器参数时要考虑用构建器
* 重叠构造器模式可行，但是当有许多参数的时候，客户端代码会很难以编写，并且仍然较难以阅读。

* 构建器不直接生成想要的的对象，而是让客户端利用所有必要的参数调用构造器，得到一个builder对象，然后客户端在builder对象上调用类似于setter的方法，来设置每个相关的可选参数，最后，客户端调用无参的build方法来生成不可变的对象。

* 简而言之，如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是种不错的选择。

### 3. 用私有构造器或者枚举类型强化Singleton属性

### 4. 通过私有构造器强化不可实例化的能力
* 工具类如：java.lang.Math等不希望被实例化，实例对它没有任何意义。

* 由于只有当类不包含显式的构造器时，编译器才会生成缺省的构造器，因此我们只要让这个类包含私有构造器，它就不能被实例化了。

* 这种用法也有个副作用，它使得一个类不能被子类化。所有的构造器都必须显式或隐式的调用超类的构造器，在这种情况下，子类就没有可访问的超类构造器可调用了。


### 5. 避免创建不必要的对象
* 如果对象是不可变的，它就始终可以被重用。

* 要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。

* 当你应该重用现有的对象的时候，请不要创建新的对象。

### 6. 消除过期的对象引用
* 一般而言，只要是自己管理内存，程序员就应该警惕内存泄漏问题。一旦元素被释放掉，则该元素中包含的任何对象引用都应该被清空。

### 7. 避免使用终结方法
* 终结方法`finalizer`通常是不可预测的，也是很危险的，一般情况下是不必要的。

* Java语言规范不仅不保证终结方法会被及时地执行，而且根本就不保证它们会被执行。

* 使用终结方法有一个非常严重的性能损失。

### 8. 覆盖`equals`时请遵守通用约定
* `equals`方法实现了等价关系：
    1. **自反性**。对于任何非null的引用值x，x.equals(x)必须返回true。
    2. **对称性**。对于任何非null的引用值x和y，y.equals(x)返回true时，x.equals(y)必须返回true。
    3. **传递性**。x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也必须返回true。
    4. **一致性**。只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)应该一致的返回true。



* 以下是实现高质量equals方法的诀窍：
    1. 使用==操作符检查“参数是否为这个对象的引用”。
    2. 使用instanceof操作符检查“参数是否为正确的类型”。
    3. 把参数转换成正确的类型。



* 下面是最后的一些告诫：
    * **覆盖equals时总要覆盖hashCode**。
    * 不要企图让equals方法过于智能。
    * **不要将equals声明中的Object对象替换为其它类型**。

### 9. 覆盖equals时总要覆盖hashCode
* 在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。

* 如果两个对象根据equals(Object)方法相比是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。

* 相等的对象必须具有相等的散列码。

### 10. 始终要覆盖toString
* toString的通用约定指出，被返回的字符串应该是一个“简洁的，但信息丰富，并且易于阅读的表达形式”。

### 11. 谨慎地覆盖clone

### 12. 考虑实现Comparable接口
* compareTo方法并没有在Object中声明。相反，它是Comparable接口中唯一的方法。

* 类实现了Comparable接口，就表明它的实例具有内存的排序关系。

### 13. 使类和成员的可访问性最小
* 设计良好的模块隐藏所有的实现细节，把它的API与它的实现清晰地隔离开来。

* 尽可能地使每个类或者成员不被外界访问。

* 总而言之，你应该尽可能地降低可访问性。

### 14. 在公有类中使用访问方法而非公有域
* 应该用包含私有域和公有访问方法(getter)的类。

* 如果类可以在它所在的包的外部进行访问，就提供访问方法，以保留将来改变该类的内部表示法的灵活性。

* 总之，公有类永远都不应该暴露可变的域。

### 15. 使可变性最小化
* 不可变的类比可变类更加易于设计、实现和使用。它们不容易出错，且更加安全。

* 使类成为不可变，要遵守下面五条规则：
    1. 不要提供任何会修改对象状态的方法。
    2. 保证类不会被扩展。
    3. 使所有的域都是final的。
    4. 使所有的域都成为私有的。
    5. 确保对于任何可变组件的互斥访问。

* 坚决不要为每个get方法编写一个相应的set方法，除非有很好的理由要让类成为可变的类，否则就应该是不可变的。

### 16. 复合优先于继承
* 继承是实现代码重用的有力手段，但它并非永远是完成这项工作的最佳工具。

* 与方法调用不同的是，继承打破了封装性。

* 不用扩展现有的类，而是在新类中增加一个私有域，它引用现有类的一个实例。这种设计被称作“复合”。

* 只有当子类真正是超类的子类型时，才适用继承。换句话说，对于两个类A和B，只有当两者之间确实存在“is-a”关系的时候，类B才应该扩展类A。

### 17. 要么为继承而设计，并提供文档说明，要么就禁止继承
* 有两种方法可以禁止子类化。
    * 一是把这个类声明为final的。
    * 二是把所有的构造器都变成私有的。

### 18. 接口优于抽象类
* Java语言提供两种机制，可以用来定义允许多个实现的类型：接口和抽象类。

* 两种机制的区别在于：
    1. 抽象类允许包含某些方法的实现，但是接口则不允许。
    2. 为了实现抽象类定义的类型，类必须成为抽象类的一个子类。

* 简而言之，接口通常是定义允许多个实现的类型的最佳途径。

### 19. 接口只用于定义类型
* 当类实现接口时，接口就充当可以引用这个类的实例的类型。

* 常量接口是对接口的不良使用。

* 简而言之，接口应该只被用来定义类型，它们不应该被用来导出常量。

### 20. 类层次优于标签类
* 标签类指一个类，通过判断即能表示圆形也能表示矩形。它有许多缺点，它们充斥着样板代码，包括枚举声明、标签域以及条件语句。

* 简而言之，标签类很少有适用的时候，标签类应该用类层次来代替。

### 21. 用函数对象表示策略
* 有些语言允许程序把“调用特殊函数的能力”存储起来并传递这种能力。Java没有提供函数指针，但是可以用对象引用实现同样的功能。

* 函数指针的主要用途就是实现策略模式。

* java中实现这种模式，要声明一个接口来表示该策略，并且为每个具体策略声明一个实现了该接口的类。当一个具体策略只被使用一次时，通常使用匿名类来声明和实例化这个具体策略类。

### 22. 优先考虑静态成员类
* 嵌套类是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为它的外围类提供服务。

* 嵌套类有四种：
    * 静态成员类
    * 非静态成员类
    * 匿名类
    * 局部类


* 静态成员类的声明中包含修饰符static。非静态成员类的每个实例都隐含着与外围类的一个外围实例相关联。

* 如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中。使它成为静态成员类。

* 如果省略了static修饰符，则每个实例都将包含一个额外的指向外围对象的引用。


### 23. 请不要在新代码中使用原生态类型
* 每个泛型都定义一个原生态类型，即不带任何实际类型参数泛型名称。如List<E>相对应的原生态类型是List。

* 如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。

* 原生态类型List和参数化的类型List<Object>之间有什么区别？前者逃避了泛型检查，后者则明确告知编译器，它能持有任意类型的对象。

* 如果要使用泛型，但是不确定或者不关心实际的类型参数，就可以使用一个问号代替，称作无限制的通配符类型。

* Set<?>和Set之间有什么区别？通配符类型是安全的，原生态类型则不安全。

* 不要在新代码中使用原生态类型，有两个例外：
    1. 在类文字中必须使用原生态类型。`List.class`是合法的，但`List<String>.class`是不合法的。
    2. 使用instanceof操作符,如：`o instanceof Set`。



* Set<Object>是个参数化类型，**表示可以包含任意对象类型的一个集合**。
* Set<?>则是一个通配符类型，**表示只能包含某种未知对象类型的一个集合**。
* Set则是个**原生态类型**，它脱离了泛型系统。
* 前两者是安全的，最后一种不安全。


### 24. 消除非受检警告
* 如果无法消除警告，同时可以证明引起警告的代码是类型安全的，可以用一个@SuppressWarnings("unchecked")注解来禁止这条警告。

### 25. 列表优先于数组
* 数组与泛型相比有两个重要的不同点。首先数组是协变的，泛型是不可变的。其次数组是具体化的，泛型是通过擦除来实现的。

* 利用数组你会在运行时发现所犯的错误，利用列表你可以在编译时发现错误。

### 26. 优先考虑泛型
* 只要时间允许，就把现有的类都泛型化。

### 27. 优先考虑泛型方法
* 就如同可以从泛型中受益一般，方法也一样。

### 28. 利用有限制通配符来提升API的灵活性

### 29. 优先考虑类型安全的异构容器
* 类Class在1.5版本中被泛化了，类的类型从字面上来看不再只是简单的Class，而是Class<T>。如：String.class属于Class<String>类型，Integer.class属于Class<Integer>类型。

* 集合的API说明了泛型的一般用法，限制你每个容器只能有固定数目的类型参数。你可以通过将类型参数放在键上而不是容器上来避开这一限制。对于这种类型安全的异构容器，可以用Class对象作为键。

### 30. 用enum代替int常量
* Java的枚举是功能十分齐全的类。

* 枚举类型背后的基本想法非常简单：它们就是通过公有的静态final域为每个枚举常量导出实例的类。

* 枚举类型还允许添加任意的方法和域，并实现任意的接口。

* 每个枚举常量后面括号中的数值就是传递给构造器的参数。

### 31. 用实例域代替序数

### 32. 用EnumSet代替位域

### 33. 用EnumMap代替序数索引

### 34. 用接口模拟可伸缩的枚举

### 35. 注解优先于命名模式

### 36. 坚持使用Override注解
* 这个注解只能用在方法声明中，它表示被注解的方法声明覆盖了超类型中的一个声明。

* 应该在你想要覆盖超类声明的每个方法声明中使用Override注解。编译器就可以替你防止大量的错误。

### 37. 用标记接口定义类型
* 标记接口是没有包含方法声明的接口，而只是指明一个类实现 了具有某种属性的接口。如Serializable接口。

### 38. 检查参数的有效性
* 对方法和构造器应该在文档中指明限制，并且在方法体的开头处检查参数，以强制施加这些限制。

* 每当编写方法时，应该考虑清楚它的参数有哪些限制，应该把这些限制写到文档中，并且在这个方法体的开头处，通过显式的检查来实施这个限制。

### 39. 必要时进行保护性拷贝
* 如果类从具有从客户端得到或者返回到客户端的可变组件，类就必须保护性的拷贝这此组件。

### 40. 谨慎设计方法签名
* 避免过长的参数列表。目标是四个参数，或者更少。

* 对于参数类型，要优先使用接口而不是类。

### 41. 慎用重载
* 对于重载方法的选择是静态的，而对于覆盖的方法的选择是动态的。

* 安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法。如果方法使用可变参数，保守的策略是根本不要重载它。

* 简而言之，“能够重载方法”并不意味着“应该重载方法”。一般情况下，对于多个具有相同参数数目的方法来说，应该尽量避免重载方法。

### 42. 慎用可变参数

### 43. 返回零长度的数组或者集合，而不是null
* 返回类型为数组或集合的方法没理由返回null，而不是返回一个零长度的数组或者集合。

### 44. 为所有导出的API元素编写文档注释
* 为了正确的编写API文档，必须在每个被导出的类、接口、构造器、方法和域声明之前增加一个文档注释。

* 方法的文档注释应该简洁地描述出它和客户端之间的约定。这个约定应该说明这个方法做了什么，而环是说明它如何完成这项工作的。

* Javadoc工具会把文档注释翻译成HTML，文档注释中包含的任意HTML元素都会出现在结果HTML文档中。

### 45. 将局部变量的作用域最小化
* 要使局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。

* 几乎每个局部变量的声明都应该包含一个初始化表达式。

### 46. for-each循环优先于传统的for循环
* 利用for-each循环不会有性能损失，甚至用于数组也一样。

* for-each循环在简洁性和预防Bug方面有着传统的for循环无法比拟的优势，并且没有性能损失。

### 47. 了解和使用类库

### 48. 如果需要精确的答案，请避免使用float和double
* float和doublle并没有提供完全精确的结果，所以不应该用于需要精确结果的场合。

* 解决这个问题的正确方法是使用BigDecimal、int或者long进行。

### 49. 基本类型优先于装箱基本类型
* 基本类型和装箱基本类型之间有三个主要区别：
    1. 基本类型只有值，而装箱基本类型具有与它们值不同的同一性。
    2. 基本类型只有功能完备的值 ，而装箱基本类型还有个功能值：null。
    3. 基本类型比装箱基本类型更节省空间和时间。

* 什么时候使用装箱基本类型：
    1. 作为集合中的元素、键和值。
    2. 在进行反射的方法调用时，必须使用装箱基本类型。


* 总之，当可以选择的时候，基本类型要优先于装箱基本类型。基本类型更加简单，也更加快速。

### 50. 如果其他类型更适合，则尽量避免使用字符串
* 字符串不适合代替其他的值类型、不适合代替枚举类型、不适合代替聚集类型、也不适合代替能力表。

* 总之，如果可以使用更加合适的数据类型，或者可以编写更加适当的数据类型，就应该避免用字符串来表示对象。

### 51. 当心字符串连接的性能
* 为了获得可以接受的性能，请使用StringBuilder代替String，StringBuilder类代替了已经过时的StringBuffer类。

* 原则很简单：不要使用字符串连接操作符来合并多个字符串，除非性能无关紧要，相反应该要使用StringBuilder的append方法。

### 52. 通过接口引用对象
* 第40条建议：应该使用接口而不是用类作为参数的类型。更一般地讲，应该优先使用接口而不是类来引用对象。

* 如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明。只有当你利用构造器创建某个对象的时候，才真正需要引用这个对象的类。

### 53. 接口优先于反射机制
* 核心反射机制提供了“通过程序来访问关于已装载的类的信息”的能力。

* 反射机制也需要付出代价：
    1. 丧失了编译时类型检查的好处。
    2. 执行反射访问所需要的代码非常笨拙和冗长。
    3. 性能损失。

### 54. 谨慎的使用本地方法（JNI）
* 使用本地方法来提高性能的做法不值得提倡。

### 55. 谨慎地进行优化
* 不要去计较效率上的一些小小的得失，在97%的情况下，砂成熟的优化才是一切问题的根源。

### 56. 遵守普遍接受的命名惯例

### 57. 只针对异常的情况才使用异常
* 异常应该只用于异常的情况下；它们永远不应该用于正常的控制流。

### 58. 对可恢复的情况使用受检异常，对编程错误使用运行时异常
* Java提供了三种可抛出的异常：受检的异常(checked exception)、运行时异常(run-time exception)和错误(error)。

### 59. 避免不必要地使用受检的异常

### 60. 优先使用标准的异常

### 61. 抛出与抽象相对应的异常

### 62. 每个方法抛出的异常都要有文档

### 63. 在细节消息中包含能捕获失败的信息

### 64. 努力使失败保持原子性

### 65. 不要忽略异常
* 空的catch块会使异常达不到应有的目的。

### 66. 同步访问共享的可变数据
* 关键字synchronized可以保证在同一时刻，只有一个线程可以执行某一个方法，或者某一个代码块。

* Java语言规范保证读或写一个变量是原子的。

* 当多个线程共享可变数据的时候，每个读写数据的线程都必须执行同步。

### 67. 避免过度同步
* 为了避免死锁和数据破坏，千万不要从同步区域内部调用外来方法。更为一般地讲，要尽量限制同步区内部的工作量。

### 68. excutor和task优先于线程
* java.util.concurrent这个包中包含了一个Executor Framework，这是一个很灵活的基于接口的任务执行工具。

### 69. 并发工具优先于wait和notify
* Java1.5平台提供了更高级的并发工具，它们可以完成以前必须在wait和notify上手写代码来完成的各项工作。

* 简而言之，直接使用wait和notify就像用“并发汇编语言”进行编程一样，而java.util.concurrent则提供了更高级的语言。

### 70. 线程安全性的文档化
* 每个类都应该利用文档说明或者线程安全注解，清楚地在文档中说明它的线程安全属性。

### 71. 慎用延迟初始化
* 大多数的域应该正常地进行初始化，而不是延迟初始化。


### 72. 不要依赖于线程调度器
* 要编写健壮的、可移植的多线程程序，最好的办法是确保可运行的线程平均数量不明显多于处理器的数量。

* 简而言之，不要让应用程序的正确性依赖于线程调度器。否则，结果得到的应用程序将既不健壮，也不具有可移植性。

### 73. 避免使用线程组

### 74. 谨慎地实现Serializable接口
* 实现Serializable接口要付出的代价：
    1. 一旦一个类被发布了，就大大降低了“改变这个类的实现”的灵活性。
    2. 它增加了出现Bug和安全漏洞的可能性。
    3. 随着类发行新的版本，相关的测试负担也增加了。


* 如果一个专门为了继承而设计的类不是可序列化的，就不可能编写出可序列化的子类。

### 75. 考虑使用自定义的序列化形式
* 当你决定要将一个类做成可序列化的时候，请仔细考虑应该采用什么样的序列化形式。只有当默认的序列代形式能够合理地描述对象的逻辑状态时，才能用默认的序列化形式。

### 76. 保护性的编写readObject方法
* readObject方法实际上相当于另一个公有的构造器。readObject是一个用“字节流作为唯一参数”的构造器。

* 简而言之，每当你编写readObject方法的时候，都要想：你正在编写一个公有构造器，无论给它传递什么样的字节流，它都必须产生一个有效的实例。

### 77. 对于实例控制，枚举类型优先于readResolve
* 对于一个正在被反序列化的对象，如果它的类定义了一个readResolve方法，并且具备正确的声明，那么在反序列化之后，新建对象上的readResolve方法就会被调用。

### 78. 考虑用序列化代理代替序列化实例
* 为可序列化的类设计一个私有的静态嵌套类，精确地表示外围类的实例的逻辑状态。这个嵌套类被称作序列化代理。

* 简而言之，每当你发现自己必须在一个不能被客户端扩展的类上编写readObject或者writeObject方法的时候，就应该考虑使用序列化代理模式。
